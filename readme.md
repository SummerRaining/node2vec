

__说明__:

1. 运行main.py，可以调用deepwalk和node2vec训练方法。
2. 运行multi-recall.py，可以查看二分网络，改进的item_cf，deepwalk，node2vec四路召回得到的结果。
3. node2vec.py，定义了deepwalk的随机游走和node2vec的游走方法。

__模型说明__:

__deepwalk__:

1. Deepwalk怎么产生游走序列的？

   遍历所有节点k次，每次遍历一个节点就产生一个序列。对于每个节点作为序列的起点，在序列当前点的邻居中任意取一个值，加入到游走序列中；依次进行该取点加入序列的操作；直到序列长度到达最大长度L或者当前点没有邻居了。

2. deepwalk怎么训练？

   将所有游走序列作为语料，使用word2vec方法训练每个节点的表示向量。使用hierarchical softmax损失函数进行训练,，cbow方法进行训练。

__node2vec__:

1. Node2vec的游走策略：

   1、p(x,v)代表从x到v的概率。P(x,v)=A(x,v)*w(x,v)，w(x,v)代表这条边的权重（多次同时购买）。

   2、设x的上一跳是t，如果t=v,A(x,v)=1/p；t和v也有边相连时,A(x,v)=1;t和v无边相连，A(x,v)=1/q。

   3、因此p代表返回概率参数，p越小跳回原节点的概率越大。q控制向外延伸的概率，q<1，网络倾向于向深处搜索DFS，q>1网络倾向于往广度搜索BFS。

2. 怎么产生游走序列？

   每个节点遍历k次，每次遍历一个节点就产生一个序列。将当前节点作为序列的起点，按照__游走策略随机选取__下一个节点加入序列中。并更新当前节点为最新加入节点，依次进行该取点加入序列的操作；直到序列长度到达最大长度L或者当前点没有邻居了。

3. node2vec怎么训练？

   依然使用word2vec训练每个节点的向量表示。

__二分网络__(Bipartite network ):

思想：将商品集合记做X，用户集合记做Y，用户和商品的关系记做E；目标是得到两个商品之间的相似度。将X集合上的权重先__传递__到Y上，然后将Y集合的权重__传递回__X上。得到x^和原x的对应关系，可以写成矩阵 x^=Wx，矩阵W就是对应任意两个商品的相似度。

具体方法，二分网络的方法是：

1. 初始化X上所有的权重，f(xi)

1. 将X上的所有权重传递到Y集合上。得到了f(yj) = sum(f(xi)/o(xi)eij)。
2. 再将Y上的所有权重传递会X集合上，得到了f’(xi) = sum(f(yj)/o(yj)eij)。
3. 最后得到f’(x)与f(x)的关系，表示为权重矩阵。F’(X) = Wf(X)，wij代表了商品i和商品j之间的相似度。

<img src = 'bipartile network.png' width = "200px" height= "300px">